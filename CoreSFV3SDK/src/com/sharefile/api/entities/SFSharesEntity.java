
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//     
//	   Copyright (c) 2014 Citrix ShareFile. All rights reserved.
// </auto-generated>
// ------------------------------------------------------------------------------

package com.sharefile.api.entities;

import com.sharefile.api.entities.*;
import com.sharefile.api.models.*;
import com.sharefile.api.models.internal.*;
import com.sharefile.api.SFApiQuery;
import com.sharefile.api.interfaces.ISFQuery;


import java.io.InputStream;
import java.util.ArrayList;
import java.net.URI;
import java.util.Date;
 
import com.google.gson.annotations.SerializedName;
import com.sharefile.api.enumerations.SFSafeEnum;

public class SFSharesEntity extends SFODataEntityBase
{
    /**
	* Get List of Shares
	* Retrieve all outstanding Shares of the authenticated user
	* @return List of Shares created by the authenticated user
    */
	public static ISFQuery<SFODataFeed<SFShare>> get()
	{
		SFApiQuery<SFODataFeed<SFShare>> sfApiQuery = new SFApiQuery<SFODataFeed<SFShare>>();
		sfApiQuery.setFrom("Shares");
		sfApiQuery.setHttpMethod("GET");
		return sfApiQuery;
	}

    /**
	* Get Share
	* Retrieve a single Share entity. If the Share allows anonymous access, then this method will not
	* require authentication.
	* @param url 	
	* @return A single Share
    */
	public ISFQuery<SFShare> get(URI url)
	{
		SFApiQuery<SFShare> sfApiQuery = new SFApiQuery<SFShare>();
		sfApiQuery.setFrom("Shares");
		sfApiQuery.addIds(url);
		sfApiQuery.setHttpMethod("GET");
		return sfApiQuery;
	}

    /**
	* Get Recipients of a Share
	* Retrieve the list of Recipients in the share. Recipients represent the target users of the Share, containing
	* access information, such as number of times that user downloaded files from the share. Each Recipient is
	* identified by an Alias, which is an unique ID given to each user - allowing tracking of downloads for
	* non-authenticated users.
	* @param url 	
	* @return A feed of Share Aliases representing recipients of the Share
    */
	public ISFQuery<SFODataFeed<SFShareAlias>> getRecipients(URI url)
	{
		SFApiQuery<SFODataFeed<SFShareAlias>> sfApiQuery = new SFApiQuery<SFODataFeed<SFShareAlias>>();
		sfApiQuery.setFrom("Shares");
		sfApiQuery.setAction("Recipients");
		sfApiQuery.addIds(url);
		sfApiQuery.setHttpMethod("GET");
		return sfApiQuery;
	}

    /**
	* Get Items of a Share
	* Retrieve the list of Items (files and folders) in the Share.
	* @param url 	
	* @return A feed of Items of the Share
    */
	public ISFQuery<SFODataFeed<SFItem>> getItems(URI url)
	{
		SFApiQuery<SFODataFeed<SFItem>> sfApiQuery = new SFApiQuery<SFODataFeed<SFItem>>();
		sfApiQuery.setFrom("Shares");
		sfApiQuery.setAction("Items");
		sfApiQuery.addIds(url);
		sfApiQuery.setHttpMethod("GET");
		return sfApiQuery;
	}

    /**
	* Get Recipients of a Share
	* Retrieve a single Item in the Share
	* @param shareUrl 	
	* @param itemid 	
	* @return An item in the Share
    */
	public ISFQuery<SFItem> getItems(URI shareUrl, String itemid)
	{
		SFApiQuery<SFItem> sfApiQuery = new SFApiQuery<SFItem>();
		sfApiQuery.setFrom("Shares");
		sfApiQuery.setAction("Items");
		sfApiQuery.addIds(shareUrl);
		sfApiQuery.addActionIds(itemid);
		sfApiQuery.setHttpMethod("GET");
		return sfApiQuery;
	}

    /**
	* Downloads Share Items
	* Downloads items from the Share. The default action will download all Items in the Share.
	* If a Share has a single item, the download attachment name
	* will use the item name. Otherwise, the download will contain a ZIP archive containing all
	* files and folders in the share, named Files.zip.To download Shares that require authentication, make sure this request is authenticated. To download
	* shares that require require user information, provide the Name, Email and Company parameters in the URI
	* query. Anyone can download files from anonymous shares.You can also download individual Items in the Share. Use the Share(id)/Items(id)/Download action. The
	* item ID must be a top-level item in the Share - i.e., you cannot download or address files contained inside
	* a shared folder.
	* @param shareUrl 	
	* @param Name 	
	* @param Email 	
	* @param Company 	
	* @param redirect 	
	* @return Redirects the caller (302) to the download address for the share contents.
    */
	public ISFQuery<InputStream> download(URI shareUrl, String id, String Name, String Email, String Company, Boolean redirect)
	{
		SFApiQuery<InputStream> sfApiQuery = new SFApiQuery<InputStream>();
		sfApiQuery.setFrom("Shares");
		sfApiQuery.setAction("Download");
		sfApiQuery.addIds(shareUrl);
		sfApiQuery.addQueryString("id", id);
		sfApiQuery.addQueryString("Name", Name);
		sfApiQuery.addQueryString("Email", Email);
		sfApiQuery.addQueryString("Company", Company);
		sfApiQuery.addQueryString("redirect", redirect);
		sfApiQuery.setHttpMethod("GET");
		return sfApiQuery;
	}

    /**
	* Create Share
    * {
    * "ShareType":"Send",
    * "Title":"Sample Send Share",
    * "Items": [ { "Id":"itemid" }, {...} ],
    * "Recipients":[ { "User": { "Id":"userid" } }, { "User": { "Email": "user@email" } } ],
    * "ExpirationDate": "2013-07-23",
    * "RequireLogin": false,
    * "RequireUserInfo": false,
    * "MaxDownloads": -1,
    * "UsesStreamIDs": false
    * }
    * {
    * "ShareType":"Request",
    * "Title":"Sample Request Share",
    * "Recipients":[ { "User": { "Id":"userid" } }, { "User": { "Email": "user@email" } } ],
    * "Parent": { "Id":"folderid" },
    * "ExpirationDate": "2013-07-23",
    * "RequireLogin": false,
    * "RequireUserInfo": false,
    * "TrackUntilDate": "2013-07-23",
    * "SendFrequency": -1,
    * "SendInterval": -1
    * }
	* Creates a new Send or Request Share.
	* Expiration date:
	* - if not specified the default is 30 days
	* - "9999-12-31" disables share expiration.
	* To use stream IDs as item IDs UsesStreamIDs needs to be set to true, and all the IDs in Items need to be specified
	* as stream IDs.
	* @param share 	
	* @param notify 	
	* @return The new Share
    */
	public ISFQuery<SFShare> create(SFShare share, Boolean notify)
	{
		SFApiQuery<SFShare> sfApiQuery = new SFApiQuery<SFShare>();
		sfApiQuery.setFrom("Shares");
		sfApiQuery.addQueryString("notify", notify);
		sfApiQuery.setBody(share);
		sfApiQuery.setHttpMethod("POST");
		return sfApiQuery;
	}

    /**
	* Modify Share
    * {
    * "Title": "New Title",
    * "ExpirationDate": "2013-07-23",
    * "RequireLogin": false,
    * "Items": [ { "Id":"itemid" }, {...} ],
    * }
	* Modifies an existing Share. If Items are specified they are added to the share.
	* @param url 	
	* @param share 	
	* @return The modified Share
    */
	public ISFQuery<SFShare> update(URI url, SFShare share)
	{
		SFApiQuery<SFShare> sfApiQuery = new SFApiQuery<SFShare>();
		sfApiQuery.setFrom("Shares");
		sfApiQuery.addIds(url);
		sfApiQuery.setBody(share);
		sfApiQuery.setHttpMethod("POST");
		return sfApiQuery;
	}

    /**
	* Delete Share
	* Removes an existing Share
	* @param url 	
    */
	public ISFQuery delete(URI url)
	{
		SFApiQuery sfApiQuery = new SFApiQuery();
		sfApiQuery.setFrom("Shares");
		sfApiQuery.addIds(url);
		sfApiQuery.setHttpMethod("DELETE");
		return sfApiQuery;
	}

    /**
	* Create Share Alias
	* Creates a share alias for the specified share ID and user email. If a user with the given email address does not
	* exist it is created first.
	* For shares requiring login an activation email is sent to the created user. If 'notify' is enabled, the user activation is
	* included in the share notification email.
	* @param url 	
	* @param email 	
	* @param notify 	
	* @return Share with the AliasID property set to the created alias ID
    */
	public ISFQuery<SFShare> createAlias(URI url, String email, Boolean notify)
	{
		SFApiQuery<SFShare> sfApiQuery = new SFApiQuery<SFShare>();
		sfApiQuery.setFrom("Shares");
		sfApiQuery.setAction("Alias");
		sfApiQuery.addIds(url);
		sfApiQuery.addQueryString("email", email);
		sfApiQuery.addQueryString("notify", notify);
		sfApiQuery.setHttpMethod("POST");
		return sfApiQuery;
	}

    /**
	* Deliver Send a File Email
	* Sends an Email to the specified list of addresses, containing a link to the specified Items.
	* The default number of expiration days is 30. -1 disables share expiration.
	* @param parameters 	
    */
	public ISFQuery createSend(SFShareSendParams parameters)
	{
		SFApiQuery sfApiQuery = new SFApiQuery();
		sfApiQuery.setFrom("Shares");
		sfApiQuery.setAction("Send");
		sfApiQuery.setBody(parameters);
		sfApiQuery.setHttpMethod("POST");
		return sfApiQuery;
	}

    /**
	* Deliver Request a File Email
	* Sends an Email to the specified list of addresses, containing a link to files upload.
	* The default number of expiration days is 30. -1 disables share expiration.
	* @param parameters 	
    */
	public ISFQuery createRequest(SFShareRequestParams parameters)
	{
		SFApiQuery sfApiQuery = new SFApiQuery();
		sfApiQuery.setFrom("Shares");
		sfApiQuery.setAction("Request");
		sfApiQuery.setBody(parameters);
		sfApiQuery.setHttpMethod("POST");
		return sfApiQuery;
	}

    /**
	* Upload File to Request Share
	* Prepares the links for uploading files to the target Share.
	* This method returns an Upload Specification object. The fields are
	* populated based on the upload method, provider, and resume parameters passed to the
	* upload call.
	* The Method determines how the URLs must be called.
	* 
	* Standard uploads use a single HTTP POST message to the ChunkUri address provided in
	* the response. All other fields will be empty. Standard uploads do not support Resume.
	* 
	* Streamed uploads use multiple HTTP POST calls to the ChunkUri address. The client must
	* append the parameters index, offset and hash to the end of the ChunkUri address. Index
	* is a sequential number representing the data block (zero-based); Offset represents the
	* byte offset for the block; and hash contains the MD5 hash of the block. The last HTTP
	* POST must also contain finish=true parameter.
	* 
	* Threaded uploads use multiple HTTP POST calls to ChunkUri, and can have a number of
	* threads issuing blocks in parallel. Clients must append index, offset and hash to
	* the end of ChunkUri, as explained in Streamed. After all chunks were sent, the client
	* must call the FinishUri provided in this spec.
	* 
	* For all uploaders, the contents of the POST Body can either be "raw", if the "Raw" parameter
	* was provided to the Uploader, or use MIME multi-part form encoding otherwise. Raw uploads
	* simply put the block content in the POST body - Content-Length specifies the size. Multi-part
	* form encoding has to pass the File as a Form parameter named "File1".
	* 
	* For streamed and threaded, if Resume options were provided to the Upload call, then the
	* fields IsResume, ResumeIndex, ResumeOffset and ResumeFileHash MAY be populated. If they are,
	* it indicates that the server has identified a partial upload with that specification, and is
	* ready to resume on the provided parameters. The clients can then verify the ResumeFileHash to
	* ensure the file has not been modified; and continue issuing ChunkUri calls from the ResumeIndex
	* ResumeOffset parameters. If the client decides to restart, it should simply ignore the resume
	* parameters and send the blocks from Index 0.
	* 
	* For all uploaders: the result code for the HTTP POST calls to Chunk and Finish Uri can either
	* be a 401 - indicating authentication is required; 4xx/5xx indicating some kind of error; or
	* 200 with a Content Body of format 'ERROR:message'. Successful calls will return either a 200
	* response with no Body, or with Body of format 'OK'.
	* @param url 	
	* @param method 	
	* @param raw 	
	* @param fileName 	
	* @param fileSize 	
	* @param batchId 	
	* @param batchLast 	
	* @param canResume 	
	* @param startOver 	
	* @param unzip 	
	* @param tool 	
	* @param overwrite 	
	* @param title 	
	* @param details 	
	* @param isSend 	
	* @param sendGuid 	
	* @param opid 	
	* @param threadCount 	
	* @param responseFormat 	
	* @param notify 	
	* @return an Upload Specification element, containing the links for uploading, and the parameters for resume. The caller must know the protocol for sending the prepare, chunk and finish URLs returned in the spec; as well as negotiate the resume upload.
    */
	public ISFQuery<SFUploadSpecification> upload(URI url, SFSafeEnum<SFUploadMethod> method, Boolean raw, String fileName, Long fileSize, String batchId, Boolean batchLast, Boolean canResume, Boolean startOver, Boolean unzip, String tool, Boolean overwrite, String title, String details, Boolean isSend, String sendGuid, String opid, Integer threadCount, String responseFormat, Boolean notify, Date clientCreatedDateUTC, Date clientModifiedDateUTC, Integer expirationDays)
	{
		SFApiQuery<SFUploadSpecification> sfApiQuery = new SFApiQuery<SFUploadSpecification>();
		sfApiQuery.setFrom("Shares");
		sfApiQuery.setAction("Upload");
		sfApiQuery.addIds(url);
		sfApiQuery.addQueryString("method", method);
		sfApiQuery.addQueryString("raw", raw);
		sfApiQuery.addQueryString("fileName", fileName);
		sfApiQuery.addQueryString("fileSize", fileSize);
		sfApiQuery.addQueryString("batchId", batchId);
		sfApiQuery.addQueryString("batchLast", batchLast);
		sfApiQuery.addQueryString("canResume", canResume);
		sfApiQuery.addQueryString("startOver", startOver);
		sfApiQuery.addQueryString("unzip", unzip);
		sfApiQuery.addQueryString("tool", tool);
		sfApiQuery.addQueryString("overwrite", overwrite);
		sfApiQuery.addQueryString("title", title);
		sfApiQuery.addQueryString("details", details);
		sfApiQuery.addQueryString("isSend", isSend);
		sfApiQuery.addQueryString("sendGuid", sendGuid);
		sfApiQuery.addQueryString("opid", opid);
		sfApiQuery.addQueryString("threadCount", threadCount);
		sfApiQuery.addQueryString("responseFormat", responseFormat);
		sfApiQuery.addQueryString("notify", notify);
		sfApiQuery.addQueryString("clientCreatedDateUTC", clientCreatedDateUTC);
		sfApiQuery.addQueryString("clientModifiedDateUTC", clientModifiedDateUTC);
		sfApiQuery.addQueryString("expirationDays", expirationDays);
		sfApiQuery.setHttpMethod("POST");
		return sfApiQuery;
	}

}

